"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signTypedData = void 0;
const parseAccount_js_1 = require("../../../accounts/utils/parseAccount.js");
const getEip712Domain_js_1 = require("../../../actions/public/getEip712Domain.js");
const signTypedData_js_1 = require("../../../actions/wallet/signTypedData.js");
const account_js_1 = require("../../../errors/account.js");
const encodePacked_js_1 = require("../../../utils/abi/encodePacked.js");
const size_js_1 = require("../../../utils/data/size.js");
const toHex_js_1 = require("../../../utils/encoding/toHex.js");
const getAction_js_1 = require("../../../utils/getAction.js");
const hashTypedData_js_1 = require("../../../utils/signature/hashTypedData.js");
const typedData_js_1 = require("../../../utils/typedData.js");
async function signTypedData(client, parameters) {
    const { account: account_ = client.account, domain, factory, factoryData, message, primaryType, types, verifier, } = parameters;
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/experimental/solady/signTypedData',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    const { domain: verifierDomain, fields, extensions, } = await (async () => {
        if (parameters.verifierDomain && parameters.fields && parameters.extensions)
            return {
                domain: parameters.verifierDomain,
                fields: parameters.fields,
                extensions: parameters.extensions,
            };
        return (0, getAction_js_1.getAction)(client, getEip712Domain_js_1.getEip712Domain, 'getEip712Domain')({
            address: verifier,
            factory,
            factoryData,
        });
    })();
    const signature = await (0, getAction_js_1.getAction)(client, signTypedData_js_1.signTypedData, 'signTypedData')({
        account,
        domain,
        types: {
            ...types,
            TypedDataSign: [
                { name: 'contents', type: primaryType },
                { name: 'fields', type: 'bytes1' },
                { name: 'name', type: 'string' },
                { name: 'version', type: 'string' },
                { name: 'chainId', type: 'uint256' },
                { name: 'verifyingContract', type: 'address' },
                { name: 'salt', type: 'bytes32' },
                { name: 'extensions', type: 'uint256[]' },
            ],
        },
        primaryType: 'TypedDataSign',
        message: {
            contents: message,
            fields,
            extensions,
            ...verifierDomain,
        },
    });
    const hashedDomain = (0, hashTypedData_js_1.hashStruct)({
        data: domain ?? {},
        types: {
            EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        },
        primaryType: 'EIP712Domain',
    });
    const hashedContents = (0, hashTypedData_js_1.hashStruct)({
        data: message,
        types: types,
        primaryType,
    });
    const encodedType = (0, hashTypedData_js_1.encodeType)({
        primaryType,
        types: types,
    });
    return (0, encodePacked_js_1.encodePacked)(['bytes', 'bytes32', 'bytes32', 'bytes', 'uint16'], [
        signature,
        hashedDomain,
        hashedContents,
        (0, toHex_js_1.stringToHex)(encodedType),
        (0, size_js_1.size)((0, toHex_js_1.stringToHex)(encodedType)),
    ]);
}
exports.signTypedData = signTypedData;
//# sourceMappingURL=signTypedData.js.map